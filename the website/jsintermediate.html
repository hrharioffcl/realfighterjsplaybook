<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript Concepts</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom scrollbar for sidebar */
    .sidebar::-webkit-scrollbar {
      width: 8px;
    }
    .sidebar::-webkit-scrollbar-track {
      background: #f1f5f9;
    }
    .sidebar::-webkit-scrollbar-thumb {
      background: #64748b;
      border-radius: 4px;
    }
    .sidebar::-webkit-scrollbar-thumb:hover {
      background: #475569;
    }
    /* Smooth scrolling for anchor links */
    html {
      scroll-behavior: smooth;
    }
    /* Code block styling */
    pre {
      background-color: #1f2937;
      color: #e5e7eb;
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
    }
    /* Table styling */
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 0.75rem;
      text-align: left;
    }
    th {
      background-color: #f3f4f6;
      font-weight: 600;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">
  <div class="flex min-h-screen">
    <!-- Sidebar -->
    <aside class="sidebar fixed top-0 left-0 w-64 h-screen bg-white shadow-lg overflow-y-auto">
      <div class="p-6">
        
         <div class="flex items-center mb-8">
       <img src="logo.png" alt="">
        <h1 class="text-2xl font-bold"></h1>
      </div>
        <nav>
          <ul class="space-y-2">
            <li><a href="#section1" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">1. Understanding this</a></li>
            <li><a href="#section2" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">2. call, apply, bind</a></li>
            <li><a href="#section3" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">3. Closures and Loop</a></li>
            <li><a href="#section4" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">4. Scope Chaining</a></li>
            <li><a href="#section5" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">5. Lexical Environment</a></li>
            <li><a href="#section6" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">6. Variable Shadowing</a></li>
            <li><a href="#section7" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">7. Function Statement vs Expression</a></li>
            <li><a href="#section8" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">8. IIFE</a></li>
            <li><a href="#section9" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">9. Higher-Order Functions</a></li>
            <li><a href="#section10" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">10. Pure Functions</a></li>
            <li><a href="#section11" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">11. Callback Functions</a></li>
            <li><a href="#section12" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">12. Callback Hell</a></li>
            <li><a href="#section13" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">13. Promises</a></li>
            <li><a href="#section14" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">14. Promise Methods</a></li>
            <li><a href="#section15" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">15. Promise.all, allSettled, race, any</a></li>
            <li><a href="#section16" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">16. Async and Await</a></li>
            <li><a href="#section17" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">17. Array Methods</a></li>
            <li><a href="#section18" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">18. Spread and Rest Operators</a></li>
            <li><a href="#section19" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">19. Destructuring</a></li>
            <li><a href="#section20" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">20. Object.freeze vs Object.seal</a></li>
            <li><a href="#section21" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">21. Deep Copy vs Shallow Copy</a></li>
            <li><a href="#section22" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">22. Set and Map</a></li>
            <li><a href="#section23" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">23. WeakSet and WeakMap</a></li>
            <li><a href="#section24" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">24. DOM Manipulation</a></li>
            <li><a href="#section25" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">25. BOM</a></li>
            <li><a href="#section26" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">26. Event Listeners</a></li>
            <li><a href="#section27" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">27. Event Bubbling and Capturing</a></li>
            <li><a href="#section28" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">28. Event Delegation</a></li>
            <li><a href="#section29" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">29. event.preventDefault and stopPropagation</a></li>
            <li><a href="#section30" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">30. Template Literals</a></li>
            <li><a href="#section31" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">31. Array Flattening</a></li>
            <li><a href="#section32" class="block text-gray-600 hover:text-blue-600 hover:bg-gray-100 px-3 py-2 rounded-md">32. LocalStorage vs SessionStorage</a></li>
          </ul>
        </nav>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="ml-64 flex-1 p-8">
      <div class="max-w-3xl mx-auto">
        <div>
        <h1 class="text-4xl  font-extrabold text-blue-800 mb-8">The Real Fighters' JS Playbook:Intermediate</h1>

        <!-- Section 1 -->
        <section id="section1" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">1. Understanding <code>this</code> in Different Contexts</h2>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Global Context</h3>
          <pre><code>console.log(this); // window (in browser)</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Inside a Function</h3>
          <pre><code>function show() {
  console.log(this);
}
show(); // window (non-strict), undefined (strict mode)</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Inside an Object Method</h3>
          <pre><code>const obj = {
  name: "Hari",
  greet: function () {
    console.log(this.name);
  }
};
obj.greet(); // "Hari"</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Inside an Arrow Function</h3>
          <pre><code>const person = {
  name: "Hari",
  greet: function () {
    const arrow = () => {
      console.log(this.name);
    };
    arrow();
  }
};
person.greet(); // "Hari"</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Summary Table: this</h3>
          <table>
            <tr><th>Context</th><th>this refers to</th></tr>
            <tr><td>Global (browser)</td><td>window</td></tr>
            <tr><td>Global (Node.js)</td><td>{} (module.exports)</td></tr>
            <tr><td>Regular function (non-strict)</td><td>window or global</td></tr>
            <tr><td>Strict mode function</td><td>undefined</td></tr>
            <tr><td>Object method</td><td>The object itself</td></tr>
            <tr><td>Arrow function</td><td>Lexical (parent) scope</td></tr>
          </table>
        </section>

        <!-- Section 2 -->
        <section id="section2" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">2. call, apply, bind</h2>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">call()</h3>
          <p class="text-gray-600 mb-4">Calls a function with a given <code>this</code> value and arguments provided individually.</p>
          <pre><code>function greet(age) {
  console.log(`Hi, I'm ${this.name} and I'm ${age} years old.`);
}
const person = { name: 'Hari' };
greet.call(person, 25); // "Hi, I'm Hari and I'm 25 years old."</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">apply()</h3>
          <p class="text-gray-600 mb-4">Same as <code>call()</code>, but arguments are passed as an array.</p>
          <pre><code>greet.apply(person, [25]); // "Hi, I'm Hari and I'm 25 years old."</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">bind()</h3>
          <p class="text-gray-600 mb-4">Returns a new function with <code>this</code> bound. Doesn't execute immediately.</p>
          <pre><code>const boundGreet = greet.bind(person, 25);
boundGreet(); // "Hi, I'm Hari and I'm 25 years old."</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Function Borrowing Example</h3>
          <pre><code>const user1 = {
  name: "Alice",
  intro: function (greeting) {
    console.log(`${greeting}, I'm ${this.name}`);
  }
};

const user2 = { name: "Bob" };

user1.intro.call(user2, "Hello"); // "Hello, I'm Bob"
user1.intro.apply(user2, ["Hi"]); // "Hi, I'm Bob"
const introBob = user1.intro.bind(user2, "Hey");
introBob(); // "Hey, I'm Bob"</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Summary Table: call vs apply vs bind</h3>
          <table>
            <tr><th>Method</th><th>Immediate Execution</th><th>Arguments Format</th><th>Returns New Function</th></tr>
            <tr><td>call</td><td>✅ Yes</td><td>Individually (arg1, arg2)</td><td>❌ No</td></tr>
            <tr><td>apply</td><td>✅ Yes</td><td>Array ([arg1, arg2])</td><td>❌ No</td></tr>
            <tr><td>bind</td><td>❌ No</td><td>Individually (arg1, arg2)</td><td>✅ Yes</td></tr>
          </table>
        </section>

        <!-- Section 3 -->
        <section id="section3" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">3. Closures and Loop Example (Memory Explained)</h2>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">📌 What is a Closure?</h3>
          <p class="text-gray-600 mb-4">A closure is a function that remembers the variables from its outer lexical scope, even after the outer function has finished executing.</p>
          <pre><code>function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const fn = outer();
fn(); // 1
fn(); // 2</code></pre>
          <p class="text-gray-600 mb-4">In the above example, <code>inner()</code> has access to <code>count</code> even after <code>outer()</code> has returned. That’s closure.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧠 Memory Behavior in Closure</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>When a function is created, it carries a reference to its surrounding variables.</li>
            <li>This reference to the surrounding variables is called its closure environment.</li>
            <li>Even after the outer function is done, this memory is retained as long as the inner function exists.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔁 Loop Example with setTimeout and var</h3>
          <pre><code>for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Output: 3, 3, 3</code></pre>

          h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔍 Why All 3 Output as 3:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><code>var</code> is function-scoped → only one shared memory for <code>i</code>.</li>
            <li><code>setTimeout</code> callbacks execute after 1000ms (after loop ends).</li>
            <li>By the time the callbacks run, <code>i</code> is already 3.</li>
            <li>Each closure refers to the same memory location.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧠 Memory Allocation (with var)</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Single memory cell for <code>i</code> (shared across all iterations).</li>
            <li>Each arrow function keeps reference to that <code>i</code>.</li>
            <li>After 1000ms, it logs the current value in that cell → 3.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">✅ Fix with let (Block Scope)</h3>
          <pre><code>for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Output: 0, 1, 2</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🛠 Why It Works:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><code>let</code> is block-scoped → new memory for <code>i</code> on every iteration.</li>
            <li>Each closure now captures a different version of <code>i</code>.</li>
            <li>So each timeout function prints its own value.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">📊 Summary Table</h3>
          <table>
            <tr><th>Type</th><th>Scope</th><th>Memory Behavior</th><th>Output</th></tr>
            <tr><td>var</td><td>Function Scope</td><td>One shared memory for i</td><td>3, 3, 3</td></tr>
            <tr><td>let</td><td>Block Scope</td><td>New memory per iteration</td><td>0, 1, 2</td></tr>
          </table>

          <p class="text-gray-600 mt-4">💡 <strong>Tip:</strong> Use <code>let</code> when creating closures in loops to ensure each function captures its own version of the variable.</p>
        </section>

        <!-- Section 4 -->
        <section id="section4" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">4. Scope Chaining</h2>
          <p class="text-gray-600 mb-4">How JavaScript resolves variables through nested scopes.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧠 What is Scope Chaining?</h3>
          <p class="text-gray-600 mb-4">Scope chaining refers to the process JavaScript uses to look up variables through nested functions or blocks. If a variable is not found in the current scope, JavaScript looks “up the chain” — moving outward through the parent scopes — until it finds the variable or reaches the global scope.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔗 Chain Example:</h3>
          <pre><code>var a = "global";

function outer() {
  var b = "outer";

  function inner() {
    var c = "inner";
    console.log(a); // ➜ "global"
    console.log(b); // ➜ "outer"
    console.log(c); // ➜ "inner"
  }

  inner();
}

outer();</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔍 How it works:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><code>inner()</code> doesn’t have <code>a</code> or <code>b</code>, so JavaScript climbs up the scope chain to find them.</li>
            <li>It finds <code>b</code> in <code>outer()</code> and <code>a</code> in the global scope.</li>
            <li>This lookup process is lexical: it depends on where functions are written, not where they're called.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧩 Important Points:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Inner functions have access to variables of their outer functions.</li>
            <li>Scope chain is created at function definition, not at runtime.</li>
            <li>If the variable is not found in any scope, you get a <code>ReferenceError</code>.</li>
          </ul>
        </section>

        <!-- Section 5 -->
        <section id="section5" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">5. Lexical Environment</h2>
          <p class="text-gray-600 mb-4">The structure holding variable bindings in a scope.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧠 What is a Lexical Environment?</h3>
          <p class="text-gray-600 mb-4">A Lexical Environment is the internal JavaScript mechanism that manages variable bindings within a scope. It is created whenever a function, block, or script is executed.</p>
          <p class="text-gray-600 mb-4">Each Lexical Environment has two main parts:</p>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><strong>Environment Record:</strong> The actual storage of variable and function declarations.</li>
            <li><strong>Outer Lexical Environment Reference:</strong> A link to the parent environment (used for scope chaining).</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔍 Example:</h3>
          <pre><code>function outer() {
  let a = 10;

  function inner() {
    let b = 20;
    console.log(a + b); // ➜ 30
  }

  inner();
}

outer();</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔗 Lexical Environment Breakdown:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>When <code>outer()</code> is called, a new Lexical Environment is created with <code>a = 10</code>.</li>
            <li>When <code>inner()</code> is defined, it keeps a reference to the outer Lexical Environment.</li>
            <li>When <code>inner()</code> runs, it creates its own Lexical Environment with <code>b = 20</code> and uses the reference to find <code>a</code>.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧩 Key Concepts:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Lexical means “based on the location in code” — i.e., structure determined during parsing, not runtime.</li>
            <li>This environment enables features like closures, scope chaining, and block scoping.</li>
            <li>Every function has its own Lexical Environment at the time it is invoked.</li>
          </ul>
        </section>

        <!-- Section 6 -->
        <section id="section6" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">6. Variable Shadowing and Illegal Shadowing</h2>
          <p class="text-gray-600 mb-4">Overriding variables in inner scopes and restrictions with let/const.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🔄 What is Variable Shadowing?</h3>
          <p class="text-gray-600 mb-4">Variable shadowing occurs when a variable declared in an inner scope has the same name as a variable in an outer scope. The inner variable “shadows” the outer one within its scope.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">✅ Example (Valid Shadowing with var):</h3>
          <pre><code>var x = 10;

function example() {
  var x = 20;
  console.log(x); // ➜ 20
}

example();
console.log(x); // ➜ 10</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🚫 Illegal Shadowing with let and var:</h3>
          <p class="text-gray-600 mb-4">You cannot redeclare a variable declared with <code>let/const</code> using <code>var</code> in the same or inner scope.</p>
          <pre><code>let a = 5;

{
  // var a = 10; ❌ SyntaxError: Identifier 'a' has already been declared
}</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">✅ Legal Shadowing with let:</h3>
          <p class="text-gray-600 mb-4">Shadowing is allowed when both variables are declared with <code>let</code> or <code>const</code> and are in different block scopes.</p>
          <pre><code>let count = 1;

{
  let count = 2;
  console.log(count); // ➜ 2 (inner scope)
}

console.log(count); // ➜ 1 (outer scope)</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">🧠 Key Concepts:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Shadowing creates a new binding in a nested scope.</li>
            <li><code>let</code> and <code>const</code> follow block scope, unlike <code>var</code> which is function scoped.</li>
            <li>Illegal shadowing prevents confusing bugs and maintains safer scope handling.</li>
          </ul>
        </section>

        <!-- Section 7 -->
        <section id="section7" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">7. Function Statement vs Function Expression</h2>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Function Statement (Function Declaration):</h3>
          <p class="text-gray-600 mb-4">Declared using the <code>function</code> keyword. Gets hoisted completely (both name and body), so it can be used before declaration.</p>
          <pre><code>foo(); // Works

function foo() {
  console.log("Function Statement");
}</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Function Expression:</h3>
          <p class="text-gray-600 mb-4">The function is assigned to a variable. Only the variable declaration is hoisted (not the function body). Cannot be used before its definition.</p>
          <pre><code>bar(); // TypeError: bar is not a function

var bar = function() {
  console.log("Function Expression");
};</code></pre>

          <p class="text-gray-600 mt-4">Summary: Function statements are fully hoisted and can be called before their definition. Function expressions are not fully hoisted and will throw an error if called before definition.</p>
        </section>

        <!-- Section 8 -->
        <section id="section8" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">8. IIFE (Immediately Invoked Function Expression)</h2>
          <p class="text-gray-600 mb-4">An IIFE is a function that is defined and executed immediately. It helps create a new scope and avoid polluting the global namespace.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Syntax:</h3>
          <pre><code>(function() {
  console.log("IIFE runs immediately!");
})();</code></pre>
          <p class="text-gray-600 mb-4">The function is wrapped in parentheses to make it an expression. The trailing <code>()</code> invokes the function immediately.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Use Cases:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><strong>Encapsulation:</strong> Variables inside the IIFE are not accessible from the outside.</li>
            <li><strong>Initialization:</strong> Useful for setting up code that runs once.</li>
            <li><strong>Avoiding global pollution:</strong> Keeps the global namespace clean.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example - Creating a Private Scope:</h3>
          <pre><code>const result = (function() {
  const privateVar = "secret";
  return privateVar;
})();

console.log(result); // Outputs: "secret"
// console.log(privateVar); // Error: privateVar is not defined</code></pre>
        </section>

        <!-- Section 9 -->
        <section id="section9" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">9. Higher-Order Functions (HOF)</h2>
          <p class="text-gray-600 mb-4">Higher-Order Functions are functions that either take other functions as arguments or return other functions as their result.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Why Use HOFs?</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Promotes code reusability and abstraction.</li>
            <li>Supports functional programming principles.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Common Examples:</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><code>Array.prototype.map()</code> – Transforms each element in an array.</li>
            <li><code>Array.prototype.filter()</code> – Filters elements based on a condition.</li>
            <li><code>Array.prototype.reduce()</code> – Reduces array to a single value.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Using map</h3>
          <pre><code>const nums = [1, 2, 3, 4];
const squares = nums.map(n => n * n);
console.log(squares); // Output: [1, 4, 9, 16]</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Returning a Function</h3>
          <pre><code>function greet(message) {
  return function(name) {
    console.log(message + ', ' + name + '!');
  };
}

const greetHello = greet("Hello");
greetHello("Alice"); // Output: Hello, Alice!</code></pre>
        </section>

        <!-- Section 10 -->
        <section id="section10" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">10. Pure Functions</h2>
          <p class="text-gray-600 mb-4">Pure Functions are functions that always return the same output for the same input and do not cause any side effects (e.g., modifying global variables, DOM, or external states).</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Why Use Pure Functions?</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Easier to test and debug.</li>
            <li>More predictable and reliable.</li>
            <li>Encourages immutability and functional programming.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Pure Function</h3>
          <pre><code>function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // Always 5</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Impure Function</h3>
          <pre><code>let counter = 0;

function increment() {
  counter++;
  return counter;
}

console.log(increment()); // Side effect: modifies external counter</code></pre>
          <p class="text-gray-600 mt-4">✅ Prefer pure functions when you want predictable and reusable logic.</p>
        </section>

        <!-- Section 11 -->
        <section id="section11" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">11. Callback Functions</h2>
          <p class="text-gray-600 mb-4">A callback function is a function passed as an argument to another function. It is typically invoked after an operation is completed, especially in asynchronous programming.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Why Use Callback Functions?</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>To handle asynchronous behavior (e.g., after an HTTP request or timer).</li>
            <li>To reuse logic flexibly by passing different functions to the same base function.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Synchronous Callback</h3>
          <pre><code>function greet(name) {
  console.log('Hello, ' + name);
}

function processUser(callback) {
  const username = 'Alice';
  callback(username);
}

processUser(greet); // Output: Hello, Alice</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example: Asynchronous Callback</h3>
          <pre><code>setTimeout(() => {
  console.log("Executed after 1 second");
}, 1000);</code></pre>
          <p class="text-gray-600 mt-4">⚠️ Overuse of callbacks in async code can lead to "callback hell." Promises and async/await are used to simplify this.</p>
        </section>

        <!-- Section 12 -->
        <section id="section12" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">12. Callback Hell</h2>
          <p class="text-gray-600 mb-4">Callback Hell refers to a situation where callbacks are nested within callbacks several levels deep, making code hard to read and maintain.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Problem Example</h3>
          <pre><code>getUser(function(user) {
  getPosts(user.id, function(posts) {
    getComments(posts[0].id, function(comments) {
      console.log(comments);
    });
  });
});</code></pre>
          <p class="text-gray-600 mb-4">This nesting makes the logic difficult to trace and scale.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">How to Avoid Callback Hell</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Use named functions instead of anonymous ones to reduce indentation.</li>
            <li>Use Promises to flatten the structure.</li>
            <li>Use async/await syntax for cleaner asynchronous flow.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example Using Promises</h3>
          <pre><code>getUser()
  .then(user => getPosts(user.id))
  .then(posts => getComments(posts[0].id))
  .then(comments => console.log(comments))
  .catch(err => console.error(err));</code></pre>
          <p class="text-gray-600 mt-4">✅ Using Promises or async/await improves readability and makes error handling easier.</p>
        </section>

        <!-- Section 13 -->
        <section id="section13" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">13. Promises</h2>
          <p class="text-gray-600 mb-4">A Promise in JavaScript is an object representing the eventual completion or failure of an asynchronous operation. It allows you to associate handlers with the outcome of an asynchronous task without deeply nesting callbacks.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Promise States</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><strong>Pending:</strong> Initial state, neither fulfilled nor rejected.</li>
            <li><strong>Fulfilled (Resolved):</strong> The operation completed successfully.</li>
            <li><strong>Rejected:</strong> The operation failed with an error.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Creating a Promise</h3>
          <pre><code>const myPromise = new Promise((resolve, reject) => {
  const success = true;
  
  if (success) {
    resolve("Promise fulfilled!");
  } else {
    reject("Promise rejected!");
  }
});</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Using Promises</h3>
          <pre><code>myPromise
  .then((result) => {
    console.log(result); // Output if resolved
  })
  .catch((error) => {
    console.error(error); // Output if rejected
  });</code></pre>
          <p class="text-gray-600 mt-4">Promises help simplify asynchronous code, making it easier to read and maintain, especially when combined with async/await.</p>
        </section>

        <!-- Section 14 -->
        <section id="section14" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">14. Promise Methods (then, catch, finally)</h2>
          <p class="text-gray-600 mb-4">JavaScript Promises come with methods that allow chaining and better control over asynchronous flows.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">then()</h3>
          <p class="text-gray-600 mb-4">Used to specify what should happen when a Promise is resolved successfully.</p>
          <pre><code>fetchData()
  .then((data) => {
    console.log("Data received:", data);
  });</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">catch()</h3>
          <p class="text-gray-600 mb-4">Used to handle errors or rejected Promises.</p>
          <pre><code>fetchData()
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error("Error:", error);
  });</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">finally()</h3>
          <p class="text-gray-600 mb-4">Executes a callback after the Promise is settled (either resolved or rejected), useful for cleanup tasks.</p>
          <pre><code>fetchData()
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error(error);
  })
  .finally(() => {
    console.log("Request completed.");
  });</code></pre>
          <p class="text-gray-600 mt-4">These methods allow better control over asynchronous operations and help avoid deeply nested code.</p>
        </section>

        <!-- Section 15 -->
        <section id="section15" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">15. Promise.all, Promise.allSettled, Promise.race, Promise.any</h2>
          <p class="text-gray-600 mb-4">These methods are used to handle multiple Promises concurrently in different ways:</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Promise.all()</h3>
          <p class="text-gray-600 mb-4">Waits for all Promises to resolve. If any Promise rejects, it fails immediately.</p>
          <pre><code>Promise.all([p1, p2, p3])
  .then(results => console.log(results))
  .catch(error => console.error(error));</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Promise.allSettled()</h3>
          <p class="text-gray-600 mb-4">Waits for all Promises to settle (either resolve or reject) and returns their status and value/reason.</p>
          <pre><code>Promise.allSettled([p1, p2, p3])
  .then(results => console.log(results));</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Promise.race()</h3>
          <p class="text-gray-600 mb-4">Resolves or rejects as soon as the first Promise settles (whichever is faster).</p>
          <pre><code>Promise.race([p1, p2, p3])
  .then(result => console.log(result))
  .catch(error => console.error(error));</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Promise.any()</h3>
          <p class="text-gray-600 mb-4">Resolves as soon as any one of the Promises resolves. Ignores rejections unless all fail.</p>
          <pre><code>Promise.any([p1, p2, p3])
  .then(result => console.log(result))
  .catch(error => console.error("All promises were rejected"));</code></pre>
          <p class="text-gray-600 mt-4">These Promise combinators are powerful tools for efficient parallel execution of asynchronous tasks.</p>
        </section>

        <!-- Section 16 -->
        <section id="section16" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">16. Async and Await</h2>
          <p class="text-gray-600 mb-4">async and await are modern JavaScript features that simplify writing asynchronous code. They make code using Promises look and behave more like synchronous code, improving readability.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">async Function</h3>
          <p class="text-gray-600 mb-4">Declaring a function with <code>async</code> means it will always return a Promise.</p>
          <pre><code>async function greet() {
  return "Hello!";
}
greet().then(alert);</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">await Keyword</h3>
          <p class="text-gray-600 mb-4">The <code>await</code> keyword can be used inside an <code>async</code> function to pause execution until the Promise resolves.</p>
          <pre><code>async function getData() {
  const response = await fetch("https://api.example.com/data");
  const data = await response.json();
  console.log(data);
}</code></pre>
          <p class="text-gray-600 mb-4">Using async/await avoids deeply nested <code>.then()</code> chains and makes error handling easier with try...catch.</p>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Example with Error Handling</h3>
          <pre><code>async function fetchData() {
  try {
    const result = await fetch("https://api.example.com");
    const data = await result.json();
    console.log(data);
  } catch (error) {
    console.error("Error fetching:", error);
  }
}</code></pre>
        </section>

        <!-- Section 17 -->
        <section id="section17" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">17. Array Methods (Map, Filter, Reduce, forEach, Find, Some, Every)</h2>
          <p class="text-gray-600 mb-4">JavaScript arrays offer powerful functional methods to manipulate and iterate over elements. Below are commonly used ones:</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">map()</h3>
          <p class="text-gray-600 mb-4">Returns a new array with the results of calling a function on every element.</p>
          <pre><code>const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2); // [2, 4, 6]</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">filter()</h3>
          <p class="text-gray-600 mb-4">Returns a new array with elements that pass the test in the callback function.</p>
          <pre><code>const nums = [1, 2, 3, 4];
const evens = nums.filter(n => n % 2 === 0); // [2, 4]</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">reduce()</h3>
          <p class="text-gray-600 mb-4">Reduces the array to a single value by executing a reducer function.</p>
          <pre><code>const nums = [1, 2, 3, 4];
const sum = nums.reduce((acc, val) => acc + val, 0); // 10</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">forEach()</h3>
          <p class="text-gray-600 mb-4">Calls a function for each array element. Doesn’t return a value.</p>
          <pre><code>const nums = [1, 2, 3];
nums.forEach(n => console.log(n));</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">find()</h3>
          <p class="text-gray-600 mb-4">Returns the first element that satisfies the condition.</p>
          <pre><code>const nums = [5, 10, 15];
const found = nums.find(n => n > 7); // 10</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">some()</h3>
          <p class="text-gray-600 mb-4">Checks if at least one element passes the test.</p>
          <pre><code>const nums = [1, 3, 5];
const hasEven = nums.some(n => n % 2 === 0); // false</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">every()</h3>
          <p class="text-gray-600 mb-4">Checks if all elements pass the test.</p>
          <pre><code>const nums = [2, 4, 6];
const allEven = nums.every(n => n % 2 === 0); // true</code></pre>
        </section>

        <!-- Section 18 -->
        <section id="section18" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">18. Spread and Rest Operators</h2>
          <p class="text-gray-600 mb-4">The <code>...</code> (three dots) syntax serves two purposes in JavaScript:</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Spread Operator</h3>
          <p class="text-gray-600 mb-4">Used to spread the elements of an array or properties of an object.</p>
          <h4 class="text-lg font-medium text-gray-700 mt-4 mb-2">Examples with Arrays:</h4>
          <pre><code>const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]</code></pre>
          <h4 class="text-lg font-medium text-gray-700 mt-4 mb-2">Examples with Objects:</h4>
          <pre><code>const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Rest Operator</h3>
          <p class="text-gray-600 mb-4">Used to collect remaining parameters into a single array or gather properties.</p>
          <h4 class="text-lg font-medium text-gray-700 mt-4 mb-2">In Function Parameters:</h4>
          <pre><code>function sum(...numbers) {
  return numbers.reduce((acc, val) => acc + val, 0);
}
sum(1, 2, 3); // 6</code></pre>
          <h4 class="text-lg font-medium text-gray-700 mt-4 mb-2">In Object Destructuring:</h4>
          <pre><code>const { a, ...rest } = { a: 1, b: 2, c: 3 };
// a = 1, rest = { b: 2, c: 3 }</code></pre>
        </section>

        <!-- Section 19 -->
        <section id="section19" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">19. Destructuring (Array and Object)</h2>
          <p class="text-gray-600 mb-4">Destructuring allows you to extract values from arrays and objects and assign them to variables in a concise way.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Array Destructuring</h3>
          <pre><code>const numbers = [10, 20, 30];
const [a, b, c] = numbers;
// a = 10, b = 20, c = 30</code></pre>
          <p class="text-gray-600 mb-4">You can skip elements or use default values:</p>
          <pre><code>const [x, , z = 0] = [1, 2];
// x = 1, z = 0</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Object Destructuring</h3>
          <pre><code>const person = { name: "Alice", age: 25 };
const { name, age } = person;
// name = "Alice", age = 25</code></pre>
          <p class="text-gray-600 mb-4">Renaming variables and setting default values:</p>
          <pre><code>const { name: userName, city = "Unknown" } = person;
// userName = "Alice", city = "Unknown"</code></pre>
        </section>

        <!-- Section 20 -->
        <section id="section20" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">20. Object.freeze vs Object.seal</h2>
          <p class="text-gray-600 mb-4">These methods are used to control the mutability of JavaScript objects:</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Object.freeze()</h3>
          <p class="text-gray-600 mb-4">Prevents adding, deleting, or modifying any properties. Makes the object completely immutable.</p>
          <pre><code>const obj = { name: "Alice" };
Object.freeze(obj);
obj.name = "Bob"; // Ignored in non-strict mode
obj.age = 30;     // Cannot add new property
delete obj.name;  // Cannot delete property</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Object.seal()</h3>
          <p class="text-gray-600 mb-4">Prevents adding or deleting properties. Allows modification of existing property values.</p>
          <pre><code>const user = { name: "John" };
Object.seal(user);
user.name = "Doe"; // Allowed
user.age = 25;     // Cannot add new property
delete user.name;  // Cannot delete property</code></pre>
          <p class="text-gray-600 mt-4">Use <code>Object.freeze</code> when you want full immutability, and <code>Object.seal</code> when you want to lock the structure but still allow updates to values.</p>
        </section>

        <!-- Section 21 -->
        <section id="section21" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">21. Deep Copy vs Shallow Copy</h2>
          <p class="text-gray-600 mb-4">These define how object data is duplicated in JavaScript:</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Shallow Copy</h3>
          <p class="text-gray-600 mb-4">Copies only top-level properties. Nested objects/arrays are still referenced.</p>
          <pre><code>const original = { name: "Tom", address: { city: "NY" } };
const copy = { ...original };
copy.address.city = "LA";
console.log(original.address.city); // "LA"</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Deep Copy</h3>
          <p class="text-gray-600 mb-4">Creates an independent copy of all nested levels. Changing the copy won't affect the original.</p>
          <pre><code>const original = { name: "Tom", address: { city: "NY" } };
const copy = structuredClone(original);
copy.address.city = "LA";
console.log(original.address.city); // "NY"</code></pre>
          <p class="text-gray-600 mt-4">Use deep copy for nested structures and shallow copy for flat objects.</p>
        </section>

        <!-- Section 22 -->
        <section id="section22" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">22. Set and Map</h2>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Set</h3>
          <p class="text-gray-600 mb-4">Stores unique values. Ignores duplicates automatically. Supports primitives and objects.</p>
          <pre><code>const set = new Set([1, 2, 2, 3]);
console.log(set); // Set(3) {1, 2, 3}</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Map</h3>
          <p class="text-gray-600 mb-4">Stores key-value pairs. Keys can be any data type (string, number, object). Maintains insertion order.</p>
          <pre><code>const map = new Map();
map.set("name", "John");
map.set(1, "One");
console.log(map.get("name")); // "John"</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Set vs Map</h3>
          <table>
            <tr><th>Feature</th><th>Set</th><th>Map</th></tr>
            <tr><td>Structure</td><td>Only values</td><td>Key-value pairs</td></tr>
            <tr><td>Uniqueness</td><td>Unique values</td><td>Unique keys</td></tr>
            <tr><td>Access</td><td>No direct access</td><td>get(key)</td></tr>
          </table>
          <p class="text-gray-600 mt-4">Use <code>Set</code> for unique items, and <code>Map</code> for structured key-value pairs.</p>
        </section>

        <!-- Section 23 -->
        <section id="section23" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">23. WeakSet and WeakMap</h2>
          <p class="text-gray-600 mb-4">WeakSet and WeakMap are special collections designed for storing objects with weak references, allowing automatic garbage collection when there are no other references.</p>
          
          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">WeakSet</h3>
          <p class="text-gray-600 mb-4">Stores only objects. Objects are weakly held, allowing garbage collection. Not iterable. Methods: <code>add(), delete(), has()</code>.</p>
          <pre><code>let ws = new WeakSet();
let user = { name: "Hari" };
ws.add(user);
user = null; // eligible for garbage collection</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">WeakMap</h3>
          <p class="text-gray-600 mb-4">Keys must be objects. Values can be any type. Not iterable. Methods: <code>set(), get(), delete(), has()</code>.</p>
          <pre><code>let wm = new WeakMap();
let obj = { id: 1 };
wm.set(obj, "private data");
obj = null; // key is garbage-collected</code></pre>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Use Cases</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Private data for objects.</li>
            <li>Metadata for DOM elements.</li>
          </ul>

          <h3 class="text-xl font-medium text-gray-700 mt-6 mb-2">Limitations</h3>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li>Cannot iterate.</li>
            <li>No way to access keys or size.</li>
          </ul>
        </section>

        <!-- Section 24 -->
        <section id="section24" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">24. DOM Manipulation</h2>
          <p class="text-gray-600 mb-4">Use JavaScript to dynamically change, add, remove, or style HTML elements.</p>
          <pre><code>document.getElementById('myId').textContent = "New Text";</code></pre>
        </section>

        <!-- Section 25 -->
        <section id="section25" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">25. BOM (Browser Object Model)</h2>
          <p class="text-gray-600 mb-4">Interacts with browser-specific objects such as:</p>
          <ul class="list-disc pl-6 text-gray-600 mb-4">
            <li><code>window.location.href</code> – current URL</li>
            <li><code>navigator.userAgent</code> – browser details</li>
            <li><code>history.back()</code> – navigate backward</li>
          </ul>
        </section>

        <!-- Section 26 -->
        <section id="section26" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">26. Event Listeners and addEventListener</h2>
          <p class="text-gray-600 mb-4">Attach functions to run when events happen on elements.</p>
          <pre><code>element.addEventListener("click", function() { alert("Clicked!"); });</code></pre>
        </section>

        <!-- Section 27 -->
        <section id="section27" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">27. Event Bubbling and Capturing</h2>
          <p class="text-gray-600 mb-4">Bubbling: Inner → Outer (default phase)</p>
          <p class="text-gray-600 mb-4">Capturing: Outer → Inner (set 3rd argument in <code>addEventListener</code> to <code>true</code>)</p>
        </section>

        <!-- Section 28 -->
        <section id="section28" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">28. Event Delegation</h2>
          <p class="text-gray-600 mb-4">Attach a single event listener to a parent, then use <code>event.target</code> to act on children. Efficient for handling dynamic child elements.</p>
        </section>

        <!-- Section 29 -->
        <section id="section29" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">29. event.preventDefault and event.stopPropagation</h2>
          <p class="text-gray-600 mb-4"><code>event.preventDefault()</code>: Prevents default behavior like navigation.</p>
          <p class="text-gray-600 mb-4"><code>event.stopPropagation()</code>: Stops the event from reaching other listeners in the DOM tree.</p>
        </section>

        <!-- Section 30 -->
        <section id="section30" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">30. Template Literals Practical</h2>
          <p class="text-gray-600 mb-4">Use backticks ` to embed variables and expressions in strings:</p>
          <pre><code>const msg = `Hello ${user.name}`;</code></pre>
        </section>

        <!-- Section 31 -->
        <section id="section31" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">31. Array Flattening (flat, flatMap)</h2>
          <p class="text-gray-600 mb-4"><code>array.flat()</code>: Flattens nested arrays</p>
          <p class="text-gray-600 mb-4"><code>array.flatMap(fn)</code>: Maps each element and flattens the result</p>
        </section>

        <!-- Section 32 -->
        <section id="section32" class="mb-12">
          <h2 class="text-2xl font-semibold text-gray-800 mb-4">32. LocalStorage vs SessionStorage</h2>
          <p class="text-gray-600 mb-4"><code>localStorage</code>: Persistent storage even after browser is closed.</p>
          <pre><code>localStorage.setItem("key", "value");</code></pre>
          <p class="text-gray-600 mb-4"><code>sessionStorage</code>: Data clears when the tab is closed.</p>
          <pre><code>sessionStorage.setItem("key", "value");</code></pre>
        </section>
      </div>
    </main>
  </div>
</body>
</html>